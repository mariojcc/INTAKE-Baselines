# -*- coding: utf-8 -*-
"""CalculatePredictionError.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qOHfgBEFprKpCYGudEk176oICNqsrioq
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/Colab Notebooks/INTAKE

from os import path
import numpy as np
def processData():
    months = ['Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep','Oct', 'Nov', 'Dec']
    months31Days = ['Aug', 'Jul','Mar','May','Oct', 'Dec']
    days=[]
    for i in range(1,32):
      if (i < 10):
        i = '0' + str(i)
      days.append(str(i))
    data = []
    predictions = []
    ground_truth = []
    dataGroundTruthPrefix = 'data/medianmodel_'
    dataPredictionsPrefix = 'data/medianmodel_acc_pred_'
    for i in range(len(months)):
      for j in range(len(days)):
        if (not j == 30 or months[i] in months31Days):
          dataGroundTruthPath = dataGroundTruthPrefix + days[j] + '-' + months[i] + '-2020.asc'
          dataPredictionPath1 = dataPredictionsPrefix + days[j] + '-' + months[i] + '-2020_1.asc'
          dataPredictionPath2 = dataPredictionsPrefix + days[j] + '-' + months[i] + '-2020_2.asc'
          dataPredictionPath3 = dataPredictionsPrefix + days[j] + '-' + months[i] + '-2020_3.asc'
          if (not (path.exists(dataGroundTruthPath) and path.exists(dataPredictionPath1) and path.exists(dataPredictionPath2) and path.exists(dataPredictionPath3))):
            continue
          ground_truth.append(np.array(np.genfromtxt(dataGroundTruthPath, dtype=None, skip_header = 6)))
          pred_region_1 = np.load(dataPredictionPath1)
          pred_region_2 = np.load(dataPredictionPath2)
          pred_region_3 = np.load(dataPredictionPath3)
          pred_region_1_2 = np.concatenate((pred_region_1, pred_region_2), axis=0)
          predictions.append(np.concatenate((pred_region_1_2, pred_region_3), axis=0))
    ground_truth = np.array(ground_truth)
    predictions = np.array(predictions)
    print(ground_truth.shape)
    print(predictions.shape)

    return ground_truth,predictions

ground_truth, predictions = processData()

def calcPercentError(ground_truth, prediction):
  error = np.zeros(ground_truth.shape)
  for i in range(ground_truth.shape[0]):
    for j in range(ground_truth.shape[1]):
      if (ground_truth[i,j] == None or prediction[i,j] == None):
        error[i,j] = None
        continue
      error[i,j] = 2*abs(prediction[i, j]-ground_truth[i, j])/(abs(ground_truth[i, j])+abs(prediction[i, j]))
  return error

import torch
import matplotlib.pyplot as plt
mse = torch.nn.MSELoss(reduction='none')
eps = 1e-6
ground_truth[ground_truth == -999.250] = None
losses = []
losses_rmse = []
losses_percentual = np.zeros(ground_truth.shape)
for i in range(ground_truth.shape[0]):
  loss = mse(torch.from_numpy(ground_truth[i,:,:]).float(), torch.from_numpy(predictions[i,:,:]).float())
  loss_rmse = torch.sqrt(loss)
  losses_percentual[i] = calcPercentError(ground_truth[i,:,:], torch.from_numpy(predictions[i,:,:]))
  losses.append(loss)
  losses_rmse.append(loss_rmse)

print(losses_percentual.shape)

losses_weekly = []
losses_rmse_weekly = []
losses_percentual_weekly = []
for i in range(len(losses)):
  if (i % 7 == 0):
    if (i != 0):
      losses_weekly.append(acc_losses / 7)
      losses_rmse_weekly.append(acc_losses_rmse / 7)
      losses_percentual_weekly.append(acc_losses_percentual / 7)
    acc_losses = torch.clone(losses[i])
    acc_losses_rmse = torch.clone(losses_rmse[i])
    acc_losses_percentual = torch.clone(torch.from_numpy(losses_percentual[i]))
  else:
    acc_losses += losses[i]
    acc_losses_rmse += losses_rmse[i]
    acc_losses_percentual += losses_percentual[i]

remainder = len(losses)%7
if (remainder != 0):
  losses_weekly.append(acc_losses / remainder)
  losses_rmse_weekly.append(acc_losses_rmse / remainder)
  losses_percentual_weekly.append(acc_losses_percentual / remainder)

print(len(losses_percentual_weekly))

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install wandb -qqq
# import wandb

!wandb login

masked_array = np.ma.masked_invalid(losses_rmse_weekly[18])
fig = plt.figure(figsize=(16, 12))
cmap = plt.cm.Reds
cmap.set_bad(color='white')
plt.imshow(masked_array, cmap=cmap)
plt.axis('off')
plt.colorbar()
plt.show()

import math
import random

# 1️⃣ Start a new run, tracking config metadata
wandb.init(project="intake-predict-eval", config={
    "dropout_r1": 0.4,
    "dropout_r2": 0.4,
    "dropout_r3": 0.0,
    "architecture": "ST-CFD",
    "dataset": "01Sep-31Dez",
})
config = wandb.config
dayIdx = 0
weekIdx = 0
# Simulating a training or evaluation loop

for i in range(len(losses)):
    # 2️⃣ Log metrics from your script to W&B
    validPixels = [x for row in losses[i] for x in row if not np.isnan(x)]
    mse = sum(validPixels)/len(validPixels)
    wandb.log(
        {
            "Daily/MSE": mse,
            "day": dayIdx
        }
    )
    dayIdx += 1
dayIdx = 0
for i in range(len(losses_rmse)):
    # 2️⃣ Log metrics from your script to W&B
    validPixels = [x for row in losses_rmse[i] for x in row if not np.isnan(x)]
    rmse = sum(validPixels)/len(validPixels)
    wandb.log(
        {
            "Daily/RMSE":rmse,
            "day": dayIdx
        }
    )
    dayIdx += 1

dayIdx = 0
for i in range(len(losses_percentual)):
    # 2️⃣ Log metrics from your script to W&B
    validPixels = [x for row in losses_percentual[i] for x in row if not np.isnan(x)]
    percent_err = sum(validPixels)/len(validPixels)
    wandb.log(
        {
            "Daily/Percentual":percent_err,
            "day": dayIdx
        }
    )
    dayIdx += 1

for j in range(len(losses_weekly)):
    validPixels = [x for row in losses_weekly[j] for x in row if not np.isnan(x)]
    mse = sum(validPixels)/len(validPixels)
    wandb.log(
        {
            "Weekly/MSE":mse,
            "week": weekIdx
        }
    )
    weekIdx += 1

weekIdx = 0
for j in range(len(losses_rmse_weekly)):
    validPixels = [x for row in losses_rmse_weekly[j] for x in row if not np.isnan(x)]
    rmse = sum(validPixels)/len(validPixels)
    wandb.log(
        {
            "Weekly/RMSE":rmse,
            "week": weekIdx
        }
    )

    masked_array = np.ma.masked_invalid(losses_rmse_weekly[j])
    fig = plt.figure()
    cmap = plt.cm.Reds
    cmap.set_bad(color='white')
    plt.imshow(masked_array, cmap=cmap)
    plt.axis('off')
    plt.colorbar()

    wandb.log({f"Heatmap (RMSE) Week:{weekIdx+1}": plt})
    plt.close()

    weekIdx += 1

weekIdx = 0
for j in range(len(losses_percentual_weekly)):
    validPixels = [x for row in losses_percentual_weekly[j] for x in row if not np.isnan(x)]
    percent_err = sum(validPixels)/len(validPixels)
    wandb.log(
        {
            "Weekly/ Percentual":percent_err,
            "week": weekIdx
        }
    )
    weekIdx += 1

wandb.finish()

import pandas as pd
import seaborn as sns
def boxPlot(plotDf, key, xKey, timePeriod):

  # Make plot
  fig, ax = plt.subplots(figsize=(35, 25))
  print(plotDf)
  print("Entering sns")
  g = sns.boxplot(ax=ax, data=plotDf, x=xKey, y=key, palette="Set2", showfliers=True, showmeans=True)
  print("Exiting sns")

  # Fix axis
  g.set_xlabel(xKey, fontsize=20)
  g.set_ylabel(key, fontsize=20)
  g.set_yticklabels(g.get_yticks(), size=16)
  g.set_xticklabels(g.get_xticks(), size=14)

  #plt.savefig('boxplot', dpi=150)
  # Upload it as a stand alone image as well
  plt.savefig(join(wandb.run.dir, f'BoxPlot-{timePeriod}-{key}.png'), dpi=150)

  # Upload it as wandb plot
  # wandb.log({f'Boxplot/{timePeriod}/{key}': fig})

  plt.close()

def boxPlotPerDay(errorList, key):
  plotDf = None
  for i in range(len(errorList)):
    dailyErrPerValidDot = [x for row in errorList[i] for x in row if not np.isnan(x)]
    auxDf = pd.Series(dailyErrPerValidDot).to_frame(name=key)
    auxDf['Day'] = i
    plotDf = auxDf if plotDf is None else pd.concat([plotDf, auxDf], ignore_index=False)
  print("Bos plotting")
  boxPlot(plotDf, key, 'Day', 'daily')

def boxPlotPerWeek(errorList, key):
  plotDf = None
  for i in range(len(errorList)):
    weeklyErrPerValidDot = [x for row in errorList[i] for x in row if not np.isnan(x)]
    auxDf = pd.Series(weeklyErrPerValidDot).to_frame(name=key)
    auxDf['Week'] = i
    plotDf = auxDf if plotDf is None else pd.concat([plotDf, auxDf], ignore_index=False)
  print(plotDf)
  #boxPlot(plotDf, key, 'Week', 'weekly')

boxPlotPerWeek(losses_rmse_weekly, key='RMSE')